

module into_Sdram (

    input clk,  // clock
    input rst,

    input red[8],
    input green[8],
    input blue[8],
    input writeFifo2,
    
    input readFifoFlag,  //
    
    
    input hdmi_vsyncFlag,
    
    output<Memory.master> memOut,    // memory interface
    input<Memory.slave> memIn,
    

    output getFifo,
    
    //output notConnected[8],
    
    output out
    
  ) {  
  
  .clk(clk) {
    .rst(rst) {
      fsm state = {IDLE, READ, WRITE, WAIT, WRITE_BUFFER_TO_SDRAM}; // our state machine
      
      // RAM may not be ready for each pixel so we need to buffer the writes
      mem_write_buffer buffer (#DEPTH(32));      
    }    
    
    dff pixelAddress[15]; // need 15 bits for 33 panels x 680 => 22,440 pixels per mojo

    dff panelControl1[2];
    
    dff rgbPixelsBuffer[24]; 
    
  }
  
    // asyncronous fifo for crossing clock domains (pclk to clk)
  async_fifo fifo (#SIZE(24), #DEPTH(64), .wclk(clk), .rclk(clk), .wrst(rst), .rrst(rst));
  

  always {
      
    fifo.wput = writeFifo2;   // always put data into the fifo
    fifo.rget = 0;   // always get data from the fifo
   
    
    fifo.din[7:0] = red;
    fifo.din[15:8] = green;
    fifo.din[23:16] = blue;
    
    buffer.memIn = memIn;                             // connect buffer to RAM
    memOut = buffer.memOut;
 
    buffer.devIn.valid = 0;                           // not valid
    buffer.devIn.write = 1;                           // always a write
    buffer.devIn.data = rgbPixelsBuffer.q;                       // connect data
    buffer.devIn.addr = pixelAddress.q;                       // connect address    
    
    getFifo = 0;    
   
    out = 0;    
    
    if(hdmi_vsyncFlag)
    {
      pixelAddress.d = 0;
      panelControl1.d = 0;    
    }
    

    if(panelControl1.q == 0){
      if(!fifo.empty)
      { 
        fifo.rget = 1;
        rgbPixelsBuffer.d = fifo.dout[23:0];
        panelControl1.d = 1;
      }
    }
    
    if(panelControl1.q == 1){
      if (!buffer.devOut.busy) {                    // if buffer isn't full (busy)
        buffer.devIn.valid = 1;                     // new command
        pixelAddress.d = pixelAddress.q + 1;                        // increment the address
        panelControl1.d = 0;
        state.d = state.IDLE;
        if(pixelAddress.q > 22440)  //this is required so it doesn't roll?
          panelControl1.d = 2;
      }
    }
    
   

    if(panelControl1.q == 3) 
    {
      //state.d = state.WRITE; 
    }   
    

    case (state.q) { // our FSM
      state.IDLE:
        out = 1;
      state.READ:
        out = 1;      
      state.WRITE_BUFFER_TO_SDRAM:
        out = 1;
      state.WRITE:
        out = 0;
    }

  }
}
