// sets display area of the HDMI screen to project to the APA102 led grid...   
// x from 40 to 448
// y from 30 to 250

//dragging the mouse over the above acstive screen area the 2nd LED (led[1]) to turn ON


//6/16/18 - made minimal for testing
//7/1/18 - took 21.minimal2 post toor camp and modified it with 1 fifo to ram for one panel writing
//7/1/18 - hdmi_in0 changed to 24 bit ram for panel_0.
//7/1/18 - hdmi-in0 changed fifo to 24bit got rid of some jitters
///.... writing 3 panels 2040 pixels to ram...
//7/1/18 = hdmi_in2 - writing to one panel
//7/1/18 - hdmi_in3 -writing one panel perfectly :)
//7/1/18 - hdmi_in5 - chasing the beam on one panel.. writing
//7/3/18 - hdmi_in6 - 3 panels writing.. a tiny glitcy, panel 2 is backward, and 2 and 3 have pixels missing.. good enough to test the wall theory
//7/4/18 - hdmi_in8 - after trying all 33 panels.. reverted back to 3 panels to clean up the code a bit.
//          ... taking out the extra flip-flop that was trying to substantiate v-sync. got rid of some flickering. panel 2 still writing backward 
//          ... all 3 panels missing pixels
//... I broke 8... too many changes.. found the big flaw.. wrapped it into 9.
//7/4/18 - hdmi_in9 - wrapped a few changes into hdmi_in9. Still a tiny bit flickery.
//7/4/18 - hdmi_in9 - three panels writing all rows... a tiny flickery. going to 10.
//7/4/18 - hdmi_in11 - changed to clock to 90mhz and spi divider at 3... for 11.25mhz (spi) seemed to reduce flickering
//7/4/18 - hdmi_in11 - running clock speed at 150mhz and divder at 3 for 9.34mhz(spi) seemed to eliminate ficker for 3 panels..

//7/4/18 - hdmi_in12 - 3 panesl working BL, TR, BL
//7/5/18 - hdmi_in13 - got transmit pixel working to show where i'm at
//7/6/18 - abandoned 14 and 15.
//       - hdmi_in16 - got 3 more panels writing.. probably 6 total..
//       - had to include spi_clk for all 3 of panels 3,4&5 or there was a tiny flicker
//7/6/18 - hdmi_in20 - got 3 panels working out of 6... again.. also got rid of most of the spi jitter (red stripes) on the 2nd panels.. still a bit jittery thought
//7/6/18 - hdmi_in21 - six panels working at reduced frame rate.. just a tiny blinky for panels #2... running at 140mhz...
//7/6/18 - hdmi_in22 - six panels (1st and last panel) working at reduced frame rate.. just a tiny blinky for panels #2... running at 140mhz...
//7/6/18 - @ 140mhz last panel ends at about 34,300....
//7/6/18 - hdmi_in23 - tried 130mhz.. no difference... finished last row at 1C (middle 8 bits) didn't check the high bits... 
//7/6/18 - hdmi_in23 - tried 160mhz... red stripes on last middle panel..
//7/6/18 - hdmi_in23 - tried 100mhz... looks OK accept for middle panels.... 38,911 pixels at end of writing.. started at 22,440.. so took 16,511 hdmi pixels at 100mhz
//7/6/18 - hdmi_in23 - tried 120mhz ... 36,351 pixels at end of writing.... but bottom right panel is a little glitchy...
//7/6/18 - hdmi_in23 - trying 130mhz again... 35,000 pixels at end of writing... ... just a little right/left glitch on right panels (top and bottom)
//                    - 130mhz seems the best so far...


module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    //output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    
    input hdmi2_tmds [4],   // HDMI In
    input hdmi2_tmdsb [4],
    inout hdmi2_sda,        // EDID Interface
    input hdmi2_scl,
        
    output apa102_data0,
    output apa102_data1,
    output apa102_data2,
    output apa102_data3,
    output apa102_data4,
    output apa102_data5,

    
    output apa102_sck
    

  ) {
  
  sig rst;  // reset signal
  
  panelRows panelRows; //#1
  
  hdmi_to_fifo hdmi_to_fifo(.rst(rst));
  
  sig fclk; // 100MHz clock
 
  // boost clock to 100MHz
  clk_wiz_v3_6 clk_wiz;
  always {
    clk_wiz.CLK_IN1 = clk;   // 50MHz in
    fclk = clk_wiz.CLK_OUT1; // 100MHz out (it's like magic!)
  }

  .clk(fclk) {
  
        // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst){

    panel_0 panel_0;
    panel_1 panel_1;
    panel_2 panel_2;
    panel_3 panel_3;
    panel_4 panel_4;
    panel_5 panel_5; 
      
      
    spi_master0 spi_out0;
    spi_master1 spi_out1;
    spi_master2 spi_out2;
    spi_master3 spi_out3;
    spi_master4 spi_out4;
    spi_master5 spi_out5;
       
    fifo_buffer fifo_buffer;
       
    avr_interface avr(#CLK_FREQ(130000000));
      
    
    }
    edid_rom edid (.rst(rst), .sda(hdmi2_sda), .scl(hdmi2_scl));
  }
    
  always {

    // connect inputs of avr
    
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
 

    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    avr.cclk = cclk;
    avr.spi_ss = spi_ss;
    avr.spi_mosi = spi_mosi;
    avr.spi_sck = spi_sck;
    avr.rx = avr_tx;
    avr.channel = hf; // ADC is unused so disable
    avr.tx_block = avr_rx_busy; // block TX when AVR is busy
 
    // connect outputs of avr
    spi_miso = avr.spi_miso;
    spi_channel = avr.spi_channel;
    avr_rx = avr.tx;
    avr.new_tx_data = 0;
    avr.tx_data = 0;
    
    
    //avr.tx_data = fifo_buffer.postFifoPixelCount[23:16];
    avr.tx_data = fifo_buffer.postFifoPixelCount[15:8];
    //avr.tx_data = fifo_buffer.postFifoPixelCount[7:0];
    avr.new_tx_data = panel_3.printSomething;
    //panel_0.txBusy = avr.tx_busy;
   
    
    fifo_buffer.hdmi_clk = hdmi_to_fifo.hdmiClk;
    fifo_buffer.writeFifo = hdmi_to_fifo.writeFifo;
    
    fifo_buffer.redIn = hdmi_to_fifo.redOut;
    fifo_buffer.greenIn = hdmi_to_fifo.greenOut;
    fifo_buffer.blueIn = hdmi_to_fifo.blueOut;
    
    fifo_buffer.hdmi_vsyncFlag = hdmi_to_fifo.hdmi_vsyncFlag;
    
    fifo_buffer.notWriting = panel_0.idle;
    
     // connect HDMI input
    hdmi_to_fifo.tmds = hdmi2_tmds;
    hdmi_to_fifo.tmdsb = hdmi2_tmdsb;
    
    
    fifo_buffer.writePixelAddress0 = panel_0.ramPixelAddress;
    fifo_buffer.writePixelAddress1 = panel_1.ramPixelAddress;
    fifo_buffer.writePixelAddress2 = panel_2.ramPixelAddress;
    fifo_buffer.writePixelAddress3 = panel_3.ramPixelAddress;
    fifo_buffer.writePixelAddress4 = panel_4.ramPixelAddress;
    fifo_buffer.writePixelAddress5 = panel_5.ramPixelAddress;
    
        
    panel_0.rgbIn = fifo_buffer.rgbOut0;
    panel_1.rgbIn = fifo_buffer.rgbOut1;
    panel_2.rgbIn = fifo_buffer.rgbOut2;
    panel_3.rgbIn = fifo_buffer.rgbOut3;
    panel_4.rgbIn = fifo_buffer.rgbOut4;
    panel_5.rgbIn = fifo_buffer.rgbOut5;
    

    panelRows.address0 = fifo_buffer.rowPixelAddress;
    panelRows.address1 = fifo_buffer.rowPixelAddress;
    panelRows.address2 = fifo_buffer.rowPixelAddress;
    panelRows.address3 = fifo_buffer.rowPixelAddress;
    panelRows.address4 = fifo_buffer.rowPixelAddress;
    panelRows.address5 = fifo_buffer.rowPixelAddress;
    
    fifo_buffer.rowStartPixel0 = panelRows.rowPixelPanel0;
    fifo_buffer.rowStartPixel1 = panelRows.rowPixelPanel1;
    fifo_buffer.rowStartPixel2 = panelRows.rowPixelPanel2;
    fifo_buffer.rowStartPixel3 = panelRows.rowPixelPanel3;
    fifo_buffer.rowStartPixel4 = panelRows.rowPixelPanel4;
    fifo_buffer.rowStartPixel5 = panelRows.rowPixelPanel5;
    
   
    panel_0.startWritingFlag = fifo_buffer.startWritingFlag;
    panel_1.startWritingFlag = fifo_buffer.startWritingFlag;
    panel_2.startWritingFlag = fifo_buffer.startWritingFlag;
    panel_3.startWritingFlag = fifo_buffer.startWritingFlag1;
    panel_4.startWritingFlag = fifo_buffer.startWritingFlag1;
    panel_5.startWritingFlag = fifo_buffer.startWritingFlag1;

    spi_out0.data_in = panel_0.ledByteOut;
    spi_out0.start = panel_0.newSpiData;
    panel_0.spiBusySignal = spi_out0.busy;

    spi_out1.data_in = panel_1.ledByteOut;
    spi_out1.start = panel_1.newSpiData;
    panel_1.spiBusySignal = spi_out1.busy;

    spi_out2.data_in = panel_2.ledByteOut;
    spi_out2.start = panel_2.newSpiData;
    panel_2.spiBusySignal = spi_out2.busy;

    spi_out3.data_in = panel_3.ledByteOut;
    spi_out3.start = panel_3.newSpiData;
    panel_3.spiBusySignal = spi_out3.busy;

    spi_out4.data_in = panel_4.ledByteOut;
    spi_out4.start = panel_4.newSpiData;
    panel_4.spiBusySignal = spi_out4.busy;

    spi_out5.data_in = panel_5.ledByteOut;
    spi_out5.start = panel_5.newSpiData;
    panel_5.spiBusySignal = spi_out5.busy;

          

    spi_out0.miso = 1b0;
    spi_out1.miso = 1b0;
    spi_out2.miso = 1b0;
    spi_out3.miso = 1b0;
    spi_out4.miso = 1b0;
    spi_out5.miso = 1b0;

    apa102_data0 = spi_out0.mosi;
    apa102_data1 = spi_out1.mosi;
    apa102_data2 = spi_out2.mosi;
    apa102_data3 = spi_out3.mosi;
    apa102_data4 = spi_out4.mosi;
    apa102_data5 = spi_out5.mosi;
    
    
    //need atleast one out of 3 panels pushing the clock
    apa102_sck = bx;
    
    if(panel_0.idle == 0)
      apa102_sck = spi_out0.sck;
    if(panel_1.idle == 0)
      apa102_sck = spi_out1.sck;
    if(panel_2.idle == 0)
      apa102_sck = spi_out2.sck;
    if(panel_3.idle == 0)
      apa102_sck = spi_out3.sck;
    if(panel_4.idle == 0)
      apa102_sck = spi_out4.sck;
    if(panel_5.idle == 0)
      apa102_sck = spi_out5.sck;

    //if(panel_0.idle == 1)
      //apa102_data0 = 0;
    //if(panel_1.idle == 1)
      //apa102_data1 = 0;
    //if(panel_2.idle == 1)
      //apa102_data2 = 0;
    //if(panel_3.idle == 1)
      //apa102_data3 = 0;
    //if(panel_4.idle == 1)
      //apa102_data4 = 0;
    //if(panel_5.idle == 1)
      //apa102_data5 = 0;               


    //panelRows.address0 = panel_0.rowPixelAddress;
    //panel_0.rowStartPixel = panelRows.rowPixelPanel0;     
 
  }
}

  
