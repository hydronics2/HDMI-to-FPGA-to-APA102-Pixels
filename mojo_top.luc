// sets display area of the HDMI screen to project to the APA102 led grid...   
// x from 40 to 448
// y from 30 to 250

//dragging the mouse over the above acstive screen area the 2nd LED (led[1]) to turn ON


//6/16/18 - made minimal for testing
//7/1/18 - took 21.minimal2 post toor camp and modified it with 1 fifo to ram for one panel writing
//7/1/18 - hdmi_in0 changed to 24 bit ram for panel_0.
//7/1/18 - hdmi-in0 changed fifo to 24bit got rid of some jitters
///.... writing 3 panels 2040 pixels to ram...
//7/1/18 = hdmi_in2 - writing to one panel
//7/1/18 - hdmi_in3 -writing one panel perfectly :)
//7/1/18 - hdmi_in5 - chasing the beam on one panel.. writing
//7/3/18 - hdmi_in6 - 3 panels writing.. a tiny glitcy, panel 2 is backward, and 2 and 3 have pixels missing.. good enough to test the wall theory
//7/4/18 - hdmi_in8 - after trying all 33 panels.. reverted back to 3 panels to clean up the code a bit.
//          ... taking out the extra flip-flop that was trying to substantiate v-sync. got rid of some flickering. panel 2 still writing backward 
//          ... all 3 panels missing pixels
//... I broke 8... too many changes.. found the big flaw.. wrapped it into 9.
//7/4/18 - hdmi_in9 - wrapped a few changes into hdmi_in9. Still a tiny bit flickery.
//7/4/18 - hdmi_in9 - three panels writing all rows... a tiny flickery. going to 10.
//7/4/18 - hdmi_in11 - changed to clock to 90mhz and spi divider at 3... for 11.25mhz (spi) seemed to reduce flickering
//7/4/18 - hdmi_in11 - running clock speed at 150mhz and divder at 3 for 9.34mhz(spi) seemed to eliminate ficker for 3 panels..

//7/4/18 - hdmi_in12 - working BL, TR, BL

module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    //output led [8],         // 8 user controllable LEDs
    //input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    //input spi_ss,           // AVR SPI Slave Select
    //input spi_mosi,         // AVR SPI MOSI
    //input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
   //input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    //input avr_rx_busy,       // AVR RX buffer full
    
    input hdmi2_tmds [4],   // HDMI In
    input hdmi2_tmdsb [4],
    inout hdmi2_sda,        // EDID Interface
    input hdmi2_scl,
        
    output apa102_data0,
    output apa102_data1,
    output apa102_data2,
    
    output apa102_sck
    

  ) {
  
  sig rst;  // reset signal
  
  panelRows panelRows; //#1
  
  hdmi_to_fifo hdmi_to_fifo(.rst(rst));
  
  sig fclk; // 100MHz clock
 
  // boost clock to 100MHz
  clk_wiz_v3_6 clk_wiz;
  always {
    clk_wiz.CLK_IN1 = clk;   // 50MHz in
    fclk = clk_wiz.CLK_OUT1; // 100MHz out (it's like magic!)
  }

  .clk(fclk) {
  
        // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst){

    panel_0 panel_0;
    panel_1 panel_1;
    panel_2 panel_2;  
      
      
    spi_master0 spi_out0;
    spi_master1 spi_out1;
    spi_master2 spi_out2;
       
    fifo_buffer fifo_buffer;
       
    //avr_interface avr(#CLK_FREQ(100000000));
      
    
    }
    edid_rom edid (.rst(rst), .sda(hdmi2_sda), .scl(hdmi2_scl));
  }
    
  always {

    // connect inputs of avr
    
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
 

    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    //avr.cclk = cclk;
    //avr.spi_ss = spi_ss;
    //avr.spi_mosi = spi_mosi;
    //avr.spi_sck = spi_sck;
    //avr.rx = avr_tx;
    //avr.channel = hf; // ADC is unused so disable
    //avr.tx_block = avr_rx_busy; // block TX when AVR is busy
 
    // connect outputs of avr
    //spi_miso = avr.spi_miso;
    //spi_channel = avr.spi_channel;
    //avr_rx = avr.tx;
    //avr.new_tx_data = 0;
    //avr.tx_data = 0;
    
    //avr.tx_data = fifo_buffer.transmitByte;
    //avr.new_tx_data = fifo_buffer.newTxDataFlag;
    //panel_0.txBusy = avr.tx_busy;
   
    
    fifo_buffer.hdmi_clk = hdmi_to_fifo.hdmiClk;
    fifo_buffer.writeFifo = hdmi_to_fifo.writeFifo;
    
    fifo_buffer.writePixelAddress0 = panel_0.ramPixelAddress;
    fifo_buffer.writePixelAddress1 = panel_1.ramPixelAddress;
    fifo_buffer.writePixelAddress2 = panel_2.ramPixelAddress;
    
    fifo_buffer.redIn = hdmi_to_fifo.redOut;
    fifo_buffer.greenIn = hdmi_to_fifo.greenOut;
    fifo_buffer.blueIn = hdmi_to_fifo.blueOut;
    

        
    panel_0.rgbIn = fifo_buffer.rgbOut0;
    panel_1.rgbIn = fifo_buffer.rgbOut1;
    panel_2.rgbIn = fifo_buffer.rgbOut2;
    

   
    fifo_buffer.hdmi_vsyncFlag = hdmi_to_fifo.hdmi_vsyncFlag;
    
    fifo_buffer.notWriting = panel_0.idle;
    
    panelRows.address0 = fifo_buffer.rowPixelAddress;
    panelRows.address1 = fifo_buffer.rowPixelAddress;
    panelRows.address2 = fifo_buffer.rowPixelAddress;
    
    fifo_buffer.rowStartPixel0 = panelRows.rowPixelPanel0;
    fifo_buffer.rowStartPixel1 = panelRows.rowPixelPanel1;
    fifo_buffer.rowStartPixel2 = panelRows.rowPixelPanel2;
    
    // connect HDMI input
    hdmi_to_fifo.tmds = hdmi2_tmds;
    hdmi_to_fifo.tmdsb = hdmi2_tmdsb;
    
    panel_0.startWritingFlag = fifo_buffer.startWritingFlag;
    panel_1.startWritingFlag = fifo_buffer.startWritingFlag;
    panel_2.startWritingFlag = fifo_buffer.startWritingFlag;

    spi_out0.data_in = panel_0.ledByteOut;
    spi_out0.start = panel_0.newSpiData; 
    panel_0.spiBusySignal = spi_out0.busy;   

    spi_out1.data_in = panel_1.ledByteOut;
    spi_out1.start = panel_1.newSpiData; 
    panel_1.spiBusySignal = spi_out1.busy;

    spi_out2.data_in = panel_2.ledByteOut;
    spi_out2.start = panel_2.newSpiData; 
    panel_2.spiBusySignal = spi_out2.busy;                

    spi_out0.miso = 1b0;
    apa102_data0 = spi_out0.mosi;
    
    spi_out1.miso = 1b0;
    apa102_data1 = spi_out1.mosi;
    
    spi_out2.miso = 1b0;
    apa102_data2 = spi_out2.mosi;

    
    apa102_sck = spi_out0.sck;
    apa102_sck = spi_out1.sck;
    apa102_sck = spi_out2.sck;

    //panelRows.address0 = panel_0.rowPixelAddress;
    //panel_0.rowStartPixel = panelRows.rowPixelPanel0;     
 
  }
}

  
