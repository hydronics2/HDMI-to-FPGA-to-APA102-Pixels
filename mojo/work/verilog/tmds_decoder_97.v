/*
   This file was generated automatically by the Mojo IDE version B1.3.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module tmds_decoder_97 (
    input rst,
    input pclk,
    input pclkx2,
    input pclkx10,
    input strobe,
    input data_p,
    input data_n,
    input others_valid,
    input others_ready,
    output reg valid,
    output reg ready,
    output reg c0,
    output reg c1,
    output reg de,
    output reg [7:0] data
  );
  
  
  
  wire [5-1:0] M_des_data;
  reg [1-1:0] M_des_data_p;
  reg [1-1:0] M_des_data_n;
  reg [1-1:0] M_des_strobe;
  reg [1-1:0] M_des_bitslip;
  serdes_1_to_5_101 des (
    .gclk(pclkx2),
    .ioclk(pclkx10),
    .rst(rst),
    .data_p(M_des_data_p),
    .data_n(M_des_data_n),
    .strobe(M_des_strobe),
    .bitslip(M_des_bitslip),
    .data(M_des_data)
  );
  
  wire [1-1:0] M_bit_align_flip;
  wire [1-1:0] M_bit_align_bitslip;
  wire [1-1:0] M_bit_align_aligned;
  reg [10-1:0] M_bit_align_data;
  bit_align_102 bit_align (
    .clk(pclk),
    .rst(rst),
    .data(M_bit_align_data),
    .flip(M_bit_align_flip),
    .bitslip(M_bit_align_bitslip),
    .aligned(M_bit_align_aligned)
  );
  reg [1:0] M_c_d, M_c_q = 1'h0;
  reg M_data_enabled_d, M_data_enabled_q = 1'h0;
  reg [7:0] M_data_out_d, M_data_out_q = 1'h0;
  wire [1-1:0] M_channel_align_ready;
  wire [10-1:0] M_channel_align_data_out;
  reg [10-1:0] M_channel_align_data_in;
  reg [1-1:0] M_channel_align_data_valid;
  reg [1-1:0] M_channel_align_others_ready;
  channel_align_103 channel_align (
    .clk(pclk),
    .data_in(M_channel_align_data_in),
    .data_valid(M_channel_align_data_valid),
    .others_ready(M_channel_align_others_ready),
    .ready(M_channel_align_ready),
    .data_out(M_channel_align_data_out)
  );
  
  reg M_flipx2_d, M_flipx2_q = 1'h0;
  reg [1:0] M_bitslipx2_d, M_bitslipx2_q = 1'h0;
  reg [4:0] M_saved_data_d, M_saved_data_q = 1'h0;
  reg [9:0] M_raw_data_d, M_raw_data_q = 1'h0;
  reg M_toggle_d, M_toggle_q = 1'h0;
  
  reg [7:0] flipped_data;
  
  integer i;
  
  always @* begin
    M_bitslipx2_d = M_bitslipx2_q;
    M_toggle_d = M_toggle_q;
    M_c_d = M_c_q;
    M_data_out_d = M_data_out_q;
    M_flipx2_d = M_flipx2_q;
    M_raw_data_d = M_raw_data_q;
    M_saved_data_d = M_saved_data_q;
    M_data_enabled_d = M_data_enabled_q;
    
    valid = M_bit_align_aligned;
    ready = M_channel_align_ready;
    M_des_data_n = data_n;
    M_des_data_p = data_p;
    M_des_strobe = strobe;
    M_bitslipx2_d[0+0-:1] = M_bit_align_bitslip;
    M_bitslipx2_d[1+0-:1] = !M_bitslipx2_q[0+0-:1] & M_bit_align_bitslip;
    M_des_bitslip = M_bitslipx2_q[1+0-:1];
    M_saved_data_d = M_des_data;
    M_flipx2_d = M_bit_align_flip;
    M_toggle_d = ~M_toggle_q;
    if (M_toggle_q ^ M_flipx2_q) begin
      M_raw_data_d = {M_des_data, M_saved_data_q};
    end
    M_bit_align_data = M_raw_data_q;
    M_channel_align_others_ready = others_ready;
    M_channel_align_data_valid = others_valid & M_bit_align_aligned;
    M_channel_align_data_in = M_raw_data_q;
    c0 = M_c_q[0+0-:1];
    c1 = M_c_q[1+0-:1];
    de = M_data_enabled_q;
    data = M_data_out_q;
    flipped_data = M_channel_align_data_out[9+0-:1] ? ~M_channel_align_data_out[0+7-:8] : M_channel_align_data_out[0+7-:8];
    if (others_ready && M_channel_align_ready) begin
      
      case (M_channel_align_data_out)
        10'h354: begin
          M_c_d = 2'h0;
          M_data_enabled_d = 1'h0;
        end
        10'h0ab: begin
          M_c_d = 2'h1;
          M_data_enabled_d = 1'h0;
        end
        10'h154: begin
          M_c_d = 2'h2;
          M_data_enabled_d = 1'h0;
        end
        10'h2ab: begin
          M_c_d = 2'h3;
          M_data_enabled_d = 1'h0;
        end
        default: begin
          M_data_enabled_d = 1'h1;
          M_data_out_d[0+0-:1] = flipped_data[0+0-:1];
          for (i = 1'h1; i < 4'h8; i = i + 1) begin
            M_data_out_d[(i)*1+0-:1] = M_channel_align_data_out[8+0-:1] ? (flipped_data[(i)*1+0-:1] ^ flipped_data[(i - 1'h1)*1+0-:1]) : (flipped_data[(i)*1+0-:1] ~^ flipped_data[(i - 1'h1)*1+0-:1]);
          end
        end
      endcase
    end
  end
  
  always @(posedge pclkx2) begin
    M_flipx2_q <= M_flipx2_d;
    M_bitslipx2_q <= M_bitslipx2_d;
    M_saved_data_q <= M_saved_data_d;
    M_raw_data_q <= M_raw_data_d;
    
    if (rst == 1'b1) begin
      M_toggle_q <= 1'h0;
    end else begin
      M_toggle_q <= M_toggle_d;
    end
  end
  
  
  always @(posedge pclk) begin
    if (rst == 1'b1) begin
      M_c_q <= 1'h0;
      M_data_enabled_q <= 1'h0;
      M_data_out_q <= 1'h0;
    end else begin
      M_c_q <= M_c_d;
      M_data_enabled_q <= M_data_enabled_d;
      M_data_out_q <= M_data_out_d;
    end
  end
  
endmodule
