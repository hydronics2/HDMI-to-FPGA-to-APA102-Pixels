module panel_32 (
    input clk,  // clock
    input rst,

    input spi32BusySignal,
    output newSpiData32,
    output ledByteOut32[8],    
        
    output rowPixelAddress[5],
    input rowStartPixel[15], 
    
    input startWritingFlag,    
    
    output<Memory.master> memOut32,    // memory interface
    input<Memory.slave> memIn32,    
  
    output out
    
  ) {
  
  const X_LENGTH = 34; //34 pixels wide
  const Y_LENGTH = 21; //20 pixels deep
  
  
  .clk(clk) {
    .rst(rst) {
      fsm state = {IDLE, READ, WRITE, WAIT, WRITE_BUFFER_TO_SDRAM}; // our state machine      
    }
    
    dff ledStartBitCounter[4];
    dff rgbCounter[4];
    dff xAxis2[6]; //panel width for counting write cycles
    dff yAxis[5];  //panel size 34 x 20 pixels 
    
    dff pixelAddress[15]; // need 15 bits for 33 panels x 680 => 22,440 pixels per mojo   
    
    dff panelControl1[2];    
 
    dff rgbPixels[24];    
  }  

  always {  
    out = 0;    
    
    memOut32.valid = 0;                           // not valid
    memOut32.write = 1;                           // always a write
    memOut32.addr = pixelAddress.q;                       // connect address   
    
    newSpiData32 = 0;
    ledByteOut32 = 0;
    
    rowPixelAddress = 0;      
   
    if(startWritingFlag == 1)
    { 
      panelControl1.d = 3;
      ledStartBitCounter.d = 0;
      yAxis.d = 0;
      xAxis2.d = 0;
    }    

    if(panelControl1.q == 3) 
    {
      state.d = state.WRITE; 
    }       

    case (state.q) { // our FSM
      state.IDLE:
        out = 1;

      state.READ:
        out = 1;
      
      state.WRITE_BUFFER_TO_SDRAM:
        out = 1;
        
        // Write LEDs to strip
      state.WRITE:
        if(ledStartBitCounter.q < 5 && !spi32BusySignal)  //send atleast 32 0s first
        {  
          ledByteOut32 = 8b0;
          newSpiData32 = 1;
          ledStartBitCounter.d = ledStartBitCounter.q + 1;
 
          rowPixelAddress = 0;     
          pixelAddress.d = 15d22406; //start for panel 32 - bl         
          rgbCounter.d = 0;
          
        }
        if(ledStartBitCounter.q == 5) //1st led frame    
        { 
          if(!memIn32.busy){
            memOut32.valid = 1;            // command is valid
            memOut32.write = 0;            // perform a read
            memOut32.addr = pixelAddress.q;
            ledStartBitCounter.d = 6; 
          }
        }
        if(ledStartBitCounter.q == 6) //1st led frame    
        {         
          if(memIn32.valid) //need to wait for the memory to be valid
          {
            rgbPixels.d = memIn32.data[23:0];
            ledStartBitCounter.d = 7;
            rgbCounter.d = 0;
            if(yAxis.q[0])  //if first bit of 0-19 rows returns a 1(true) then even rows and we count up
            {
              pixelAddress.d = pixelAddress.q - 1;
            }
            else{
              pixelAddress.d = pixelAddress.q + 1;
            }
          }
        }

        if(ledStartBitCounter.q == 7)
        {
          if(rgbCounter.q == 0 && !spi32BusySignal)
          {
            xAxis2.d = xAxis2.q + 1;
            ledByteOut32 = 8he3; //3 bits 1 and 5 bits brightness, tried E3, E5, 77
            newSpiData32 = 1;               
            rgbCounter.d = 1;
          }
          if(rgbCounter.q == 1 && !spi32BusySignal)
          { 
            ledByteOut32 = rgbPixels.q[23:16];
            newSpiData32 = 1;
            rgbCounter.d = 2;
          }          
          if(rgbCounter.q == 2 && !spi32BusySignal)
          { 
            ledByteOut32 = rgbPixels.q[15:8];
            newSpiData32 = 1;
            rgbCounter.d = 3;
          }  
          if(rgbCounter.q == 3 && !spi32BusySignal)
          { 
            ledByteOut32 = rgbPixels.q[7:0];
            newSpiData32 = 1;
            rgbCounter.d = 4;
          }
          if(rgbCounter.q == 4) //wrote RG&B
          { 
            if(xAxis2.q == X_LENGTH) //34 ... last pixel in row
            {
              rgbCounter.d = 5; //get 1st pixel in next row
              yAxis.d = yAxis.q + 1; //increment rwo
            }else
            {
              rgbCounter.d = 0;
              ledStartBitCounter.d = 5; //get the next pixel from SDram
            }
          } 
          if(rgbCounter.q == 5) //get 1st pixel in next row
          {     
            rowPixelAddress = yAxis.q;     //this has to be here.. can't be assigned globally for some reason...
            pixelAddress.d = rowStartPixel;
            rgbCounter.d = 0;
            xAxis2.d = 0;
            ledStartBitCounter.d = 5;  //get the next pixel from SDram
  
            if(yAxis.q == Y_LENGTH) //end if wrote 0-19 rows
            {
              ledStartBitCounter.d = ledStartBitCounter.q + 1; 
            }
          }
        }
        
        if(ledStartBitCounter.q > 7 && ledStartBitCounter.q < 13 && !spi32BusySignal) //end frame 4+ bytes of 8hFF
        {  
          ledByteOut32 = 8hff;
          newSpiData32 = 1;
          ledStartBitCounter.d = ledStartBitCounter.q + 1;
        } 
        if(ledStartBitCounter.q == 13)
        {
          panelControl1.d = 0;
          state.d = state.IDLE;
        }
      } 
  }
}