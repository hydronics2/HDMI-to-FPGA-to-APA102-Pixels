//Section 1.
//Panel 19.
//start Pixel is 16387 w/ 16320 offset from tr11
// tr with no cutouts


//APA 102 led strips receive data as follows
//  Start frame 32 bits ZEROS
// LED FRAME consists of three bits 111.... and 5 bits brightnes value followed by one byte each blue, green, red..
// end frame is 4 bytes 8hFF.


module panel_19 (

    input clk,  // clock
    input rst,

    input spiBusySignal,
    output newSpiData,
    output ledByteOut[8],

    output rowPixelAddress[5],
    input rowStartPixel[15],
    input startWritingFlag,

    output<Memory.master> memOut2,    // memory interface
    input<Memory.slave> memIn2,


    output out

  ) {

  const X_LENGTH = 34; //34 pixels wide
  const Y_LENGTH = 21; //20 pixels deep


  .clk(clk) {
    .rst(rst) {
     fsm state = {IDLE, WRITE}; // our state machine
    }

    dff ledStartBitCounter[4];
    dff rgbCounter[4];
    dff xAxis2[6]; //panel width for counting write cycles
    dff yAxis[5];  //panel size 34 x 20 pixels

    dff pixelAddress[15]; // need 15 bits for 33 panels x 680 => 22,440 pixels per mojo

    dff panelControl1[2];

    dff rgbPixels[24];
  }


  always {

    out = 0;

    memOut2.valid = 0;                           // not valid
    memOut2.write = 1;                           // always a write
    memOut2.addr = pixelAddress.q;                       // connect address

    ledByteOut = 0;
    newSpiData = 0;

    rowPixelAddress = 0;

  

    if(startWritingFlag == 1)
    {
      panelControl1.d = 3;
      ledStartBitCounter.d = 0;
      yAxis.d = 0;
      xAxis2.d = 0;
    }


    if(panelControl1.q == 3)
    {
      state.d = state.WRITE;
    }

    case (state.q) { // our FSM
      state.IDLE:
        out = 1;

      state.WRITE:
        if(ledStartBitCounter.q < 5 && !spiBusySignal)  //send atleast 32 0s first
        {
          ledByteOut = 8b0;
          newSpiData = 1;
          ledStartBitCounter.d = ledStartBitCounter.q + 1;

          rowPixelAddress = 0;

          //START PIXEL
          pixelAddress.d = d16387;

          rgbCounter.d = 0;

        }
        if(ledStartBitCounter.q == 5) //1st led frame
        {
          if(!memIn2.busy){
            memOut2.valid = 1;            // command is valid
            memOut2.write = 0;            // perform a read
            memOut2.addr = pixelAddress.q;
            ledStartBitCounter.d = 6;
          }
        }
        if(ledStartBitCounter.q == 6) //1st led frame
        {
          if(memIn2.valid) //need to wait for the memory to be valid
          {
            rgbPixels.d = memIn2.data[23:0];
            ledStartBitCounter.d = 7;
            rgbCounter.d = 0;
            if(yAxis.q[0])  //if first bit of 0-19 rows returns a 1(true) then even rows and we count up
            {
              pixelAddress.d = pixelAddress.q + 1;
            }
            else{
              pixelAddress.d = pixelAddress.q - 1;
            }
          }
        }

        if(ledStartBitCounter.q == 7)
        {
          if(rgbCounter.q == 0 && !spiBusySignal)
          {
            xAxis2.d = xAxis2.q + 1;
            ledByteOut = 8he3; //3 bits 1 and 5 bits brightness, tried E3, E5, 77
            newSpiData = 1;
            rgbCounter.d = 1;
          }
          if(rgbCounter.q == 1 && !spiBusySignal)
          {
            ledByteOut = rgbPixels.q[23:16];
            newSpiData = 1;
            rgbCounter.d = 2;
          }
          if(rgbCounter.q == 2 && !spiBusySignal)
          {
            ledByteOut = rgbPixels.q[15:8];
            newSpiData = 1;
            rgbCounter.d = 3;
          }
          if(rgbCounter.q == 3 && !spiBusySignal)
          {
            ledByteOut = rgbPixels.q[7:0];
            newSpiData = 1;
            rgbCounter.d = 4;
          }
          if(rgbCounter.q == 4) //wrote RG&B
          {
            if(xAxis2.q == X_LENGTH) //34 ... last pixel in row
            {
              rgbCounter.d = 5; //get 1st pixel in next row
              yAxis.d = yAxis.q + 1; //increment rwo
            }else
            {
              rgbCounter.d = 0;
              ledStartBitCounter.d = 5; //get the next pixel from SDram

              //------------------------PANEL /
              //if(pixelAddress.q == d19581) //row 17 last pixel counting down
              //{
              //  yAxis.d = 9; //only needed for even and odd (count up and count down)
              //  pixelAddress.d = d19478; //first pixel in row 18
              //  xAxis2.d = 0;
             // }
             // if(pixelAddress.q == d19450)
             // {
              //  yAxis.d = 10; //only needed for even and odd (count up and count down)
             //   pixelAddress.d = d19349; //first pixel in row 19
             //   xAxis2.d = 0;
             // }
             // if(pixelAddress.q == d19377)
             // {
              //  yAxis.d = 11; //only needed for even and odd (count up and count down)
              //  pixelAddress.d = d19274; //first pixel in row 19
              //  xAxis2.d = 0;
             // }
             // if(pixelAddress.q == d19246)
             // {
                //yAxis.d = 12; //only needed for even and odd (count up and count down)
                //pixelAddress.d = d19142; //first pixel in row 19
                //xAxis2.d = 0;
              //}
            }
          }
          if(rgbCounter.q == 5) //get 1st pixel in next row
          {
            rowPixelAddress = yAxis.q;     //this has to be here.. can't be assigned globally for some reason...
            pixelAddress.d = rowStartPixel;
            rgbCounter.d = 0;
            xAxis2.d = 0;
            ledStartBitCounter.d = 5;  //get the next pixel from SDram

            if(yAxis.q == Y_LENGTH) //end if wrote 0-19 rows
            {
              ledStartBitCounter.d = ledStartBitCounter.q + 1;
            }

          }
        }

        if(ledStartBitCounter.q > 7 && ledStartBitCounter.q < 13 && !spiBusySignal) //end frame 4+ bytes of 8hFF
        {
          ledByteOut = 8hff;
          newSpiData = 1;
          ledStartBitCounter.d = ledStartBitCounter.q + 1;
        }
        if(ledStartBitCounter.q == 13)
        {
          panelControl1.d = 0;
          state.d = state.IDLE;  //not sure why this is required but gliteches out trying to take out states
        }
      }
  }
}
