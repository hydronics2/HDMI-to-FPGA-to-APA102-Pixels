module fifo_buffer (

    input clk,        // 

    input rst,        // 
    
    input hdmi_clk,
    
    input hdmi_vsyncFlag,
    
    output readFifo,
 
    input redIn[8],
    input greenIn[8],
    input blueIn[8],
    input writeFifo,
    
    input notWriting, //are we spi writing?

    output rgbOut0[24],
    output rgbOut1[24],
    output rgbOut2[24],
    output rgbOut3[24],
    output rgbOut4[24],
    output rgbOut5[24],    
    output rgbOut30[24],
    output rgbOut31[24],
    output rgbOut32[24],
    
    input writePixelAddress0[10], //Address in RAM for when writing to LEDs
    input writePixelAddress1[10],
    input writePixelAddress2[10],
    input writePixelAddress3[10],
    input writePixelAddress4[10],
    input writePixelAddress5[10],
    input writePixelAddress30[10], //Address in RAM for when writing to LEDs
    input writePixelAddress31[10],
    input writePixelAddress32[10],
    
    output startWritingFlag,
    output startWritingFlag1,
    output startWritingFlag10,
    
    output postFifoPixelCount[24], //all the LEDs
        
    output rowPixelAddress[5],
    
    input rowStartPixel0[10],
    input rowStartPixel1[10],
    input rowStartPixel2[10],
    
    input rowStartPixel3[10],
    input rowStartPixel4[10],
    input rowStartPixel5[10],

    input rowStartPixel30[10],
    input rowStartPixel31[10],
    input rowStartPixel32[10],
    
    output printSomething,
    
    output notConnected[24]
    
  ) {
 
  .clk(clk) {
    .rst(rst) {  
             
    }

    dff rgb0Counter[10];
    dff rgb1Counter[10];
    dff rgb2Counter[10];
    
    dff rowCounter[8]; //219 rows
    dff columnCounter[7]; //102 columns wide
    dff pixel[24];
    dff newPixelFlag[2];
    
    dff pixelCounter[24]; //20,433 pixels
    
    dff frameCounter[5];
    
  
    // we need our RAM to have an entry for every value of name_count
    simple_ram rgb0 (#SIZE(24), #DEPTH(700));
    simple_ram rgb1 (#SIZE(24), #DEPTH(700));
    simple_ram rgb2 (#SIZE(24), #DEPTH(700));
    
    dff readWriteFlag[3];

  }
 
 
  // reset conditioner for pclk clock domain
  reset_conditioner wrst_cond (.clk(hdmi_clk), .in(rst));
 
  // asyncronous fifo for crossing clock domains (pclk to clk)
  async_fifo fifo (#SIZE(24), #DEPTH(64), .wclk(hdmi_clk), .rclk(clk), .wrst(wrst_cond.out), .rrst(rst)); //going from 128 to 64 kept it from glitching
 
  always {
    // defaults
    notConnected = 0;
    
    printSomething = 0;
    
    startWritingFlag = 0;
    startWritingFlag1 = 0;
    startWritingFlag10 = 0;
    
    postFifoPixelCount = pixelCounter.q;

    rowPixelAddress = rowCounter.q;
    
    rgb0.address = rgb0Counter.q;
    rgb0.write_data = 8hxx;
    rgb0.write_en = 0;

    rgb1.address = rgb1Counter.q;
    rgb1.write_data = 8hxx;
    rgb1.write_en = 0;
    
    rgb2.address = rgb2Counter.q;
    rgb2.write_data = 8hxx;
    rgb2.write_en = 0;
    
    
    fifo.wput = writeFifo;   // always put data into the fifo
    fifo.rget = 0;   // always get data from the fifo
   
    fifo.din[7:0] = redIn;
    fifo.din[15:8] = greenIn;
    fifo.din[23:16] = blueIn;
 
    rgbOut0 = 0;
    rgbOut1 = 0;
    rgbOut2 = 0;
    rgbOut3 = 0;
    rgbOut4 = 0;
    rgbOut5 = 0;
    rgbOut30 = 0;
    rgbOut31 = 0;
    rgbOut32 = 0;
    
    readFifo = 0;

    if(hdmi_vsyncFlag) //start of frame... reset pixel counter
    {
      frameCounter.d = frameCounter.q + 1;
      if(frameCounter.q == 11)
        frameCounter.d = 0;
      
      readWriteFlag.d = 0;
      
      columnCounter.d = 0; 
      rowCounter.d = 1;
      newPixelFlag.d = 0;
      pixelCounter.d = 0;
      
      rgb0Counter.d = 679;
      rgb1Counter.d = 33;
      rgb2Counter.d = 679;
    }
    
    case (frameCounter.q)
    {
      0:  //read  into RAM panels 0,1,2
        if(pixelCounter.q < 2040)
        {
          if (!fifo.empty && newPixelFlag.q == 0) 
          {
            fifo.rget = 1;
            pixel.d = fifo.dout[23:0];
            
            newPixelFlag.d = 1;
          }
        }
        
      1:  //read  into RAM last frame of LEDs (panels 30,31,& 32)
        if (pixelCounter.q < 2040 && !fifo.empty) // just readout all the LED pixels before frame 3 starts..
          {
            fifo.rget = 1;
            notConnected = fifo.dout[23:0];
            pixelCounter.d = pixelCounter.q + 1;
          }
          
         if(pixelCounter.q >= 2040 && pixelCounter.q < 4090)  //ok frame 3 is starting here
          {     
            if (!fifo.empty && newPixelFlag.q == 0) 
            {
              fifo.rget = 1;
              pixel.d = fifo.dout[23:0];
              newPixelFlag.d = 1;
            }
          }
        
      10:  //read  into RAM last frame of LEDs (panels 30,31,& 32)
        if (pixelCounter.q < 20400 && !fifo.empty) // just readout all the LED pixels before frame 30 starts..
          {
            fifo.rget = 1;
            notConnected = fifo.dout[23:0];
            pixelCounter.d = pixelCounter.q + 1;
          }
          
         if(pixelCounter.q >= 20400 && pixelCounter.q < 22440) //ok frame 30 is starting here
          {     
            if (!fifo.empty && newPixelFlag.q == 0) 
            {
              fifo.rget = 1;
              pixel.d = fifo.dout[23:0];
              newPixelFlag.d = 1;
            }
          }
    }
        

    if(newPixelFlag.q == 1)
    {
      newPixelFlag.d = 2;
      
      if(columnCounter.q < 34)
      {
        rgb0.write_data = pixel.q;
        rgb0.write_en = 1;
        
        if(rowCounter.q[0])  //if first bit of 0-19 rows returns a 1(true) then even rows and we count up
        {
          rgb0Counter.d = rgb0Counter.q - 1;
        }else{
          rgb0Counter.d = rgb0Counter.q + 1;
        } 
      }
      if(columnCounter.q > 33 && columnCounter.q < 68)
      {
        rgb1.write_data = pixel.q;
        rgb1.write_en = 1;
        
        if(rowCounter.q[0])  //if first bit of 0-19 rows returns a 1(true) then even rows and we count up
        {
          rgb1Counter.d = rgb1Counter.q - 1;
        }else{
          rgb1Counter.d = rgb1Counter.q + 1;
        }
      }

      if(columnCounter.q > 67 && columnCounter.q < 102)
      {
        rgb2.write_data = pixel.q;
        rgb2.write_en = 1;
        
        if(rowCounter.q[0])  //if first bit of 0-19 rows returns a 1(true) then even rows and we count up
        {
          rgb2Counter.d = rgb2Counter.q - 1;
        }else{
          rgb2Counter.d = rgb2Counter.q + 1;
        }
      }
    }  
    
    //Adjust start and end pixels based on type of LED panel
    case (frameCounter.q) {
      0:  if(newPixelFlag.q == 2)
          {
            newPixelFlag.d = 0;
            columnCounter.d = columnCounter.q + 1;
            pixelCounter.d = pixelCounter.q + 1;
            if(columnCounter.q == 101)
            {
              rowCounter.d = rowCounter.q + 1;
              columnCounter.d = 0;
              rgb0Counter.d = rowStartPixel0;
              rgb1Counter.d = rowStartPixel1;
              rgb2Counter.d = rowStartPixel2;
            }     
          }
        
      1:  if(newPixelFlag.q == 2)
          {
            newPixelFlag.d = 0;
            columnCounter.d = columnCounter.q + 1;
            pixelCounter.d = pixelCounter.q + 1;
            if(columnCounter.q == 101)
            {
              rowCounter.d = rowCounter.q + 1;
              columnCounter.d = 0;
              rgb0Counter.d = rowStartPixel3;
              rgb1Counter.d = rowStartPixel4;
              rgb2Counter.d = rowStartPixel5;
            }     
          }
      10:  if(newPixelFlag.q == 2)
          {
            newPixelFlag.d = 0;
            columnCounter.d = columnCounter.q + 1;
            pixelCounter.d = pixelCounter.q + 1;
            if(columnCounter.q == 101)
            {
              rowCounter.d = rowCounter.q + 1;
              columnCounter.d = 0;
              rgb0Counter.d = rowStartPixel30;
              rgb1Counter.d = rowStartPixel31;
              rgb2Counter.d = rowStartPixel32;
            }     
          }
    }    
    
    //finished reading frames......
    case (frameCounter.q) {    
      0:  
        if(pixelCounter.q == 2040) //all 3 panels captured in ram
        {
          startWritingFlag = 1;
          readWriteFlag.d = 1;
          newPixelFlag.d = 0;
          pixelCounter.d = pixelCounter.q + 1;  
        }
    

      1:   
        if(pixelCounter.q == 4090) //all 3 panels captured in ram
        {
          startWritingFlag1 = 1;
          readWriteFlag.d = 1;
          newPixelFlag.d = 0;
          pixelCounter.d = pixelCounter.q + 1;
        } 
               
      10:   
        if(pixelCounter.q == 22440) //all 3 panels captured in ram
        {
          startWritingFlag10 = 1;
          readWriteFlag.d = 1;
          newPixelFlag.d = 0;
          pixelCounter.d = pixelCounter.q + 1;
        }
    }   

    
    if(readWriteFlag.q)
    {
      case (frameCounter.q) {
        0:  rgb0.address = writePixelAddress0;
            rgb0Counter.d = writePixelAddress0;
            rgbOut0 = rgb0.read_data;
            
            rgb1.address = writePixelAddress1;
            rgb1Counter.d = writePixelAddress1;
            rgbOut1 = rgb1.read_data;
            
            rgb2.address = writePixelAddress2;
            rgb2Counter.d = writePixelAddress2;
            rgbOut2 = rgb2.read_data;      
                
        1:   rgb0.address = writePixelAddress3;
              rgb0Counter.d = writePixelAddress3;
              rgbOut3 = rgb0.read_data;
              
              rgb1.address = writePixelAddress4;
              rgb1Counter.d = writePixelAddress4;
              rgbOut4 = rgb1.read_data;
              
              rgb2.address = writePixelAddress5;
              rgb2Counter.d = writePixelAddress5;
              rgbOut5 = rgb2.read_data; 
               
        10:   rgb0.address = writePixelAddress30;
            rgb0Counter.d = writePixelAddress30;
            rgbOut30 = rgb0.read_data;
            
            rgb1.address = writePixelAddress31;
            rgb1Counter.d = writePixelAddress31;
            rgbOut31 = rgb1.read_data;
            
            rgb2.address = writePixelAddress32;
            rgb2Counter.d = writePixelAddress32;
            rgbOut32 = rgb2.read_data;     
        } 
    } 
    
    
    
     //this is just for counting... to see how long it takes to finish writing based on where we are in the HDMI screen 1270x800
    if(pixelCounter.q > 22440 && !fifo.empty) //just count pixels
      {
        fifo.rget = 1;
        notConnected = fifo.dout[23:0];
        pixelCounter.d = pixelCounter.q + 1;
    }   
    
    
    
        
  }
}